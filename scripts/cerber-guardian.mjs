#!/usr/bin/env node
// Generated by Cerber init - DO NOT EDIT MANUALLY
// To regenerate: npx cerber init --force

import { execSync } from 'child_process';
import fs from 'fs';
import { join } from 'path';

const SCHEMA_FILE = 'BACKEND_SCHEMA.mjs';
const APPROVALS_TAG = 'ARCHITECT_APPROVED';

async function main() {
  console.log('ğŸ›¡ï¸  Cerber Guardian: Validating staged files...');

  if (!fs.existsSync(SCHEMA_FILE)) {
    console.error(`âŒ Schema file not found: ${SCHEMA_FILE}`);
    console.error('Create your schema file to enable validation.');
    console.error(`Example: npx cerber init --print-schema-template > ${SCHEMA_FILE}`);
    process.exit(1);
  }

  // Import schema
  let schema;
  try {
    const schemaPath = join(process.cwd(), SCHEMA_FILE);
    const schemaModule = await import(`file://${schemaPath}`);
    schema = schemaModule.BACKEND_SCHEMA || schemaModule.default || schemaModule;
  } catch (err) {
    console.error(`âŒ Failed to load schema from ${SCHEMA_FILE}:`, err.message);
    process.exit(1);
  }

  // Get staged files
  let stagedFiles;
  try {
    stagedFiles = execSync('git diff --cached --name-only', { encoding: 'utf-8' })
      .trim()
      .split('\n')
      .filter(Boolean);
  } catch (err) {
    console.error('âŒ Failed to get staged files');
    process.exit(1);
  }

  if (stagedFiles.length === 0) {
    console.log('âœ… No files staged for commit');
    return;
  }

  console.log(`Checking ${stagedFiles.length} file(s)...`);

  const violations = [];

  // Validate each staged file
  for (const file of stagedFiles) {
    if (!fs.existsSync(file)) continue;

    const content = fs.readFileSync(file, 'utf-8');

    // Check forbidden patterns
    if (schema.forbiddenPatterns && Array.isArray(schema.forbiddenPatterns)) {
      for (const rule of schema.forbiddenPatterns) {
        if (!rule.pattern) continue;

        const pattern = typeof rule.pattern === 'string' 
          ? new RegExp(rule.pattern, rule.flags || 'i') 
          : rule.pattern;
        
        // Check if file is in exceptions
        if (rule.exceptions && rule.exceptions.some(ex => file.includes(ex))) {
          continue;
        }

        if (pattern.test(content)) {
          // Check for architect approval
          const hasApproval = content.includes(APPROVALS_TAG);
          
          if (!hasApproval) {
            violations.push({
              file,
              rule: rule.name || 'Unnamed rule',
              severity: rule.severity || 'error'
            });
          }
        }
      }
    }

    // Check required imports (rules)
    if (schema.rules && Array.isArray(schema.rules)) {
      for (const rule of schema.rules) {
        if (!rule.pattern || !rule.requiredImports) continue;

        const filePattern = typeof rule.pattern === 'string' ? new RegExp(rule.pattern) : rule.pattern;
        
        if (!filePattern.test(file)) continue;

        // Check if file is in exceptions
        if (rule.exceptions && rule.exceptions.some(ex => file.includes(ex))) {
          continue;
        }

        // Check each required import
        for (const requiredImport of rule.requiredImports) {
          const importPattern = new RegExp(`import.*${requiredImport}`, 'i');
          
          if (!importPattern.test(content)) {
            // Check for architect approval
            const hasApproval = content.includes(APPROVALS_TAG);
            
            if (!hasApproval) {
              violations.push({
                file,
                rule: `${rule.name || 'Unnamed rule'}: missing import '${requiredImport}'`,
                severity: rule.severity || 'error'
              });
            }
          }
        }
      }
    }
  }

  // Report violations
  if (violations.length > 0) {
    console.error('\nâŒ Architecture violations detected:\n');
    
    for (const v of violations) {
      const icon = v.severity === 'error' ? 'ğŸ”´' : 'âš ï¸';
      console.error(`${icon} [${v.severity.toUpperCase()}] ${v.file}`);
      console.error(`   ${v.rule}`);
      console.error(`   Add ${APPROVALS_TAG} comment to override\n`);
    }
    
    const errorCount = violations.filter(v => v.severity === 'error').length;
    if (errorCount > 0) {
      console.error(`\nâŒ Commit blocked: ${errorCount} error(s) found`);
      process.exit(1);
    }
  }

  console.log('âœ… All checks passed');
}

main().catch(err => {
  console.error('âŒ Guardian check failed:', err?.message || err);
  process.exit(1);
});
